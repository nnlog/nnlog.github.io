---  
layout: post  
title: "algorithm baekjoon 10816 in java"  
image: algorithm.jpg  
categories: All algorithm  
---  

# 숫자 카드 2  

> [beakjoon 10816](https://www.acmicpc.net/problem/10816)  
>   
> **문제** : 숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 몇 개 가지고 있는지 구하는 프로그램을 작성하시오.  

<br>  

---  

## 해결  

<br>  

[10815](https://nnlog.github.io/2022/06/01/algorithm-baekjoon-10815/) 요 문제의 조건이 하나 더 붙는 문제이다.  

다른점은 주어진 카드들 중 해당 카드의 중복되는 개수를 출력하면 되는데, 이 문제 또한 이분탐색법으로 풀면된다.  

<br>  

그렇다면 어떤 점이 중요할까?  
풀다보면 막히는 부분이 나오기 마련이다. 이 문제는 특히 이분탐색법을 또 다른 시각으로 보고 풀어야하는데 나는 시간복잡도에 걸리는 풀이로 풀어서 고수분의 풀이를 참고하여 풀었다.  

<br>  

나 같은 경우 중복되는 카드의 개수를 찾기 위해 `Arrays.sort()`된 배열에 찾으려는 키값이 작거나 크거나 같은경우를 나누고 범위를 좁혀나가다 같은 값을 찾았을 때 작은 값, 큰 값쪽으로 while문을 써서 하나씩 검사하여 개수를 판단하도록 풀어 보았는데 이 경우, 모두 같은 수일때는 처음부터 끝까지 while문이 돌게 되어 시간 초과가 나오는 문제가 발생하게 된다.  

<br>  

그렇기 때문에, 정렬된 배열에서 찾으려는 키값이 처음 등장하는 인덱스 값과 마지막으로 등장하는 인덱스 값의 다음값을 구한 다음에 이 두 인덱스의 차를 구하면 중복된 개수를 알 수 있다.  
마지막으로 등장한 인덱스 값이 아닌 초과하는 그 다음 값을 이용하는 이유는 중복된 개수는 **(초과한 값의 인덱스 - 처음 등장한 값의 인덱스)**를 해주어야 나오기 때문이다.  

<br>  

예를 들어,
그림을 보자.  

![](https://user-images.githubusercontent.com/103972967/172381588-dd9e5585-c136-4779-b4d3-127efca0c271.png)  

이렇게 찾으려는 키값의 처음 등장하는 위치값, 최초로 초과하는 위치값을 알아내야하기 때문에 2개의 메소드를 생성해야 한다.  
lowIndex값을 찾는 메소드, highIndex값을 찾는 메서드로 나뉘는데 방식은 비슷하다.  

<br>  

---  

## lowIndex(), highIndex()  

<br>  

가장 처음 등장하는 값을 찾기 위해서  
`if(numN[mid] >= key) -> end = mid, else -> start = mid+1`로 범위를 좁혀가게 설계한다. 여기서 주의깊게 볼 점은 중앙값과 키값이 일치할때 end값을 mid로 설정하는 부분이다.  
lowIndex()의 경우 중복값이 나타나도 end = mid로 설정해야 end값을 움직여 low와 겹치는 부분을 찾을 수 있기 때문이다.  

범위를 좁혀나가는 과정을 이해하기 쉽게 사진을 통해 빠르게 알아보자.  

![](https://user-images.githubusercontent.com/103972967/172340664-37d24d4b-988b-477f-ab45-92cff43725b4.png)  

중앙 값이 키값과 같기 때문에 end = mid,  

![](https://user-images.githubusercontent.com/103972967/172340725-9b2cd330-23a7-4829-a64f-bf002327ff58.png)  

새로운 중앙 값이 키값보다 작기 때문에 start = mid + 1  

![](https://user-images.githubusercontent.com/103972967/172340774-a73ff887-e3f6-435d-9be2-214022ed3972.png)  

시작 인덱스와 끝 인덱스가 한칸차이면 중앙 값과 시작인덱스 위치가 같아진다. 이렇게 됐을 때 `numN[mid] >= key`에 해당하기에 end = mid로 재설정  

![](https://user-images.githubusercontent.com/103972967/172340817-b103742a-9626-4547-bb5b-06914874aa30.png)

결국 시작 인덱스와 끝 인덱스가 겹치는데 이 값이 찾으려는 값의 처음 등장하는 인덱스가 된다.  

<br>  

이렇듯 **lowIndex()**와 **highIndex()**의 다른점이라고는 중복값이 등장 했을 때 else 문으로 처리하는 것이다. 그렇게 되면 찾으려는 값을 찾았을 때 시작점이 움직여 결국 끝 값과 시작 값이 만나는 점이 바로 찾으려는 값이 처음 초과하는 값이 된다.  

이 부분은 코드를 보며 직접 그림을 그려보자. 도움이 상당히 될듯 하다.  

---  

<script src="https://gist.github.com/nnlog/71288944ca9ac7c3f0a673a2d9925589.js"></script>  

---   

p.s. `고수의 지식을 빌려 다시 한번 강화 성공이다! 😁`  