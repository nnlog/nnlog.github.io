---  
layout: post  
title: "algorithm baekjoon 10815 in java"  
image: algorithm.jpg  
categories: All algorithm  
---  

# 숫자 카드  

> [beakjoon 10815](https://www.acmicpc.net/problem/10815)  
>   
> **문제** : 숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 가지고 있는지 아닌지를 구하는 프로그램을 작성하시오.  

<br>  

---  

## 해결  

문제는 간단하다. 첫 번째로 숫자 카드 N개를 받아와서 두 번째로 숫자 카드 M개와 비교하여 있으면 1을 출력 없는 카드면 0을 출력하면 된다.  

하지만 아무렇게나 짜서 통과되는 그런 호락호락한 백준 문제가 아니다.  

<br>  

그래서 이 문제는 **이분 탐색**을 통해서 풀어 볼 것이다.  

> 여기서 이분 탐색이란?  
> 
> 이분 탐색은 중간 값을 비교하여 불필요한 탐색 범위를 줄여나가는 방법이다.  
> 
> 때문에 1부터 10까지 검사할일을 단번에 줄여주어 시간복잡도에서 훨씬 유리해진다.  

<br>  

---  

### 1. 정렬    

우선 첫번째로 N번만큼 받아온 숫자 카드들을 오름차순으로 정렬할 것이다. 이렇게 하는 이유는 중앙값을 비교 후 다음 범위를 정함에 있어 순서가 정렬되어있으면 기준을 잡기가 편해지기 때문이다.  

**예를 들어 N = {0, 1, 2, 3, 4, 5}라고 정리되어 있다면, 이중 4의 위치를 찾는 로직을 짤때 중앙값 2와 비교후 더크다면 0, 1, 2은 제외하고 3, 4, 5 중 다시 한번 중앙 값인 4와 비교하는데 이처럼 훨씬 짧은 시간안에 4의 위치를 찾을 수 있는걸 확인할 수 있다. 마치 샌드위치처럼 범위를 줄여간다고 생각하면 편하다.**  

쉽게 표로 정리해보면,  

|시작 인덱스|중간 인덱스|끝 인덱스|찾으려는 숫자|판정|  
|--|--|--|--|--|  
|[0]|[2]|[5]|4|[2] 2 < 4|  
|[3]|[4]|[5]|4|[4] 4 = 4|

<br>  

---  

### 2. 이분 탐색  

이제 문제를 해결할 방법을 알았으니 이를 식으로 옮겨보자.  

시간 단축을 위하여 BufferedReader를 사용하여 수를 입력할 것이고 일정 숫자를 찾는 로직을 메소드로 따로 만들어 볼려고 한다.  

우선 기준이 될 N번 입력 받은 배열과 찾으려는 수를 파라미터로 전해주는게 첫 번째다.  

그 후 `int start = 0 , int end = array.length() - 1, int mid = (start + end)/2`로 변수를 선언하여 범위를 정해준다.  

이어서 `while( (end - start) >= 0)` 범위가 없어질 때까지 반복하는 무한루프에 `if(array[mid] == key) return 1,  else if(array[mid] < key) start = mid+1 , else{ end = mid-1 }` 이런식으로 로직을 짜면 우리가 바라던데로 간단하게 해결할 수 있다.  

<br>  

---  

### 3. 완성본  

---  

<script src="https://gist.github.com/nnlog/077f6362dfbb3b1fb125cb26bde3e543.js"></script>  

---   

p.s. `이 방법 말고도 내가 바로 짤수 있는 로직이 있다. 그럼 뭐하나 이젠 시간복잡도를 생각해서 짤 수 있는 개발자가 되어야지!! 😞`  